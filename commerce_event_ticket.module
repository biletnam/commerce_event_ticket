<?php
/**
 * @file
 * Main file for the Commerce Event Ticket module.
 */

/**
 * Implements hook_entity_info().
 */
function commerce_event_ticket_entity_info() {
  $entities = array();

  $entities['commerce_event_ticket'] = array(
    'label' => t('Ticket'),
    'entity class' => 'CommerceEventTicketEntity',
    'controller class' => 'CommerceEventTicketController',
    'uri callback' => 'commerce_event_ticket_uri',
    'access callback' => 'commerce_event_ticket_access',
    'label callback' => 'commerce_event_ticket_label',
    'base table' => 'commerce_event_ticket',
    'token type' => 'commerce-event-ticket',
    'entity keys' => array(
      'id' => 'ticket_id',
      'bundle' => 'type',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
      ),
      'teaser' => array(
        'label' => t('Teaser'),
      ),
    ),
    'view callback' => 'entity_metadata_view_single',
    'static cache' => TRUE,
    'fieldable' => FALSE,
    'module' => 'commerce_event_ticket',
  );

  foreach (commerce_event_ticket_types() as $key => $type) {
    $entities['commerce_event_ticket']['bundles'][$key] = array(
      'label' => $type['name'],
      'admin' => array(
        'path' => 'admin/commerce/config/event-ticket/' . $key,
        'real path' => 'admin/commerce/config/event-ticket/' . $key,
        'bundle argument' => 4,
        'access arguments' => array('administer commerce event ticket'),
      ),
    );
  }

  return $entities;
}

/**
 * Implements hook_permission().
 */
function commerce_event_ticket_permission() {
  return array(
    'administer commerce event ticket' => array(
      'title' => t('Administer event tickets'),
    ),
    'view all commerce event ticket' => array(
      'title' => t('View all event tickets'),
    ),
    'view own commerce event ticket' => array(
      'title' => t('View own event tickets'),
    ),
  );
}

/**
 * Implements hook_entity_property_info().
 */
function commerce_event_ticket_entity_property_info() {
  $info = array();
  $properties = &$info['commerce_event_ticket']['properties'];
  $properties = array(
    'ticket_id' => array(
      'label' => t('Ticket ID'),
      'description' => t('Primary key'),
      'type' => 'integer',
      'schema field' => 'id',
      'required' => TRUE,
    ),
    'type' => array(
      'label' => t('Type'),
      'description' => t('The type of ticket.'),
      'type' => 'text',
      'schema field' => 'type',
      'required' => TRUE,
    ),
    'barcode_token' => array(
      'label' => t('Barcode token'),
      'description' => t('The barcode token for the ticket.'),
      'type' => 'int',
      'schema field' => 'barcode_token',
      'required' => TRUE,
    ),
    'owner' => array(
      'label' => t('Owner'),
      'description' => t('The owner of the ticket.'),
      'type' => 'user',
      'schema field' => 'uid',
      'required' => TRUE,
    ),
    'order' => array(
      'label' => t('Order'),
      'description' => t('The Commerce order associated with the ticket.'),
      'type' => 'commerce_order',
      'schema field' => 'order_id',
      'required' => TRUE,
    ),
    'line_item' => array(
      'label' => t('Line item'),
      'description' => t('The Commerce line item associated with the ticket.'),
      'type' => 'commerce_line_item',
      'schema field' => 'line_item_id',
      'required' => TRUE,
    ),
    'product' => array(
      'label' => t('Product'),
      'description' => t('The Commerce product associated with the ticket.'),
      'type' => 'commerce_product',
      'schema field' => 'product_id',
      'required' => TRUE,
    ),
  );
  return $info;
}

/**
 * Get information about Commerce Event Ticket types.
 *
 * @return array
 *   An array of ticket types, keyed with a unique machine name. Each element is
 *   a structured array, defining at least 'name' (a sanitized human-readable
 *   name).
 */
function commerce_event_ticket_types() {
  $types = &drupal_static(__FUNCTION__);
  if ($types === NULL) {
    $types = array(
      'ticket' => array(
        'name' => t('Event ticket'),
      ),
    );
    $types += module_invoke_all('commerce_event_ticket_info');
    drupal_alter('commerce_event_ticket_info', $types);
  }
  return $types;
}

/**
 * Access callback for Commerce Event Ticket.
 */
function commerce_event_ticket_access($op, $entity, $account = NULL) {
  // Operations other than 'view' make no sense.
  if ($op != 'view') {
    return FALSE;
  }
  // Deny access if the order balance has not been paid in full.
  $order = commerce_order_load($entity->order_id);
  $balance = commerce_payment_order_balance($order);
  if ($balance > 0) {
    return FALSE;
  }
  // Grant view access to relevant users.
  if (!$account) {
    $account = $GLOBALS['user'];
  }
  if (!empty($account->uid)
    && $account->uid == $entity->uid
    && user_access('view own commerce event ticket', $account)) {
    return TRUE;
  }
  if (user_access('view all commerce event ticket', $account)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Load an event ticket.
 */
function commerce_event_ticket_load($ticket_id) {
  $tickets = commerce_event_ticket_load_multiple(array($ticket_id));
  return $tickets ? reset($tickets) : FALSE;
}

/**
 * Load multiple event ticket(s).
 */
function commerce_event_ticket_load_multiple($ticket_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('commerce_event_ticket', $ticket_ids, $conditions, $reset);
}

/**
 * Save an event ticket.
 */
function commerce_event_ticket_save($ticket) {
  return entity_get_controller('commerce_event_ticket')->save($ticket);
}

/**
 * Delete an event ticket.
 */
function commerce_event_ticket_delete($ticket_id) {
  return commerce_event_ticket_delete_multiple(array($ticket_id));
}


/**
 * Delete multiple event ticket(s).
 */
function commerce_event_ticket_delete_multiple(array $ticket_ids) {
  return entity_get_controller('commerce_event_ticket')->delete($ticket_ids);
}

/**
 * Delete all the tickets associated with the specified line item.
 */
function commerce_event_ticket_delete_by_line_item($line_item) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_event_ticket')
    ->propertyCondition('line_item_id', $line_item->line_item_id);
  $result = $query->execute();
  if (!empty($result['commerce_event_ticket'])) {
    $ids = array_keys($result['commerce_event_ticket']);
    commerce_event_ticket_delete_multiple($ids);
  }
}

/**
 * Implements hook_entity_delete().
 */
function commerce_event_ticket_entity_delete($entity, $type) {
  if ($type == 'commerce_line_item') {
    commerce_event_ticket_delete_by_line_item($entity);
  }
}

/**
 * Label callback for Commerce Event Ticket.
 */
function commerce_event_ticket_label($entity) {
  $product = commerce_product_load($entity->product_id);
  return t('Ticket: @product', array('@product' => $product->title));
}

/**
 * Count the number of event tickets that already exist for a line item.
 *
 * @param int $line_item
 *   The Commerce line item object.
 *
 * @return int
 *   The number of event tickets that have already been created for this line
 *   item.
 */
function commerce_event_ticket_count($line_item) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_event_ticket')
    ->propertyCondition('line_item_id', $line_item->line_item_id);
  $result = $query->execute();
  if (isset($result['commerce_event_ticket'])) {
    return count($result['commerce_event_ticket']);
  }
  return 0;
}

/**
 * Generate a new barcode token for the ticket.
 *
 * @param string $prefix
 *   A prefix to prepend to the token.
 * @param int $length
 *   The length of the remainder of the token.
 *
 * @return string
 *   A random barcode token.
 */
function commerce_event_ticket_generate_barcode_token($prefix = '', $length = 10) {
  // Make a new random token.
  // @todo make this alterable by other modules
  $integers = range(0, 9);
  shuffle($integers);
  $token = $prefix;
  for ($i = 0; $i < $length; $i++) {
    $token .= $integers[$i];
  }
  // Check whether the token already exists.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_event_ticket')
    ->propertyCondition('barcode_token', $token)
    ->count();
  $count = $query->execute();
  // If it does already exist, then recurse to find a new token.
  if ($count) {
    return commerce_event_ticket_generate_barcode_token($length);
  }
  return $token;
}

/**
 * Create event tickets for an order.
 *
 * This is provided as a Rules action.
 *
 * @param stdClass $order
 *   The Commerce order object.
 */
function commerce_event_ticket_create_from_order($order) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  // Find line items in the order.
  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    $line_item = $line_item_wrapper->value();

    // Check that the line item is a product.
    if ($line_item->type != 'product') {
      continue;
    }

    // Check that the product is configured to have tickets.
    $product = $line_item_wrapper->commerce_product->value();
    $config = commerce_event_ticket_get_ticket_config($product);
    if (!$config) {
      continue;
    }

    // Check what quantity of tickets should be generated.
    $existing = commerce_event_ticket_count($line_item);
    $quantity_new = $line_item->quantity - $existing;

    // Generate the new tickets.
    $controller = entity_get_controller('commerce_event_ticket');
    $transaction = db_transaction();
    for ($number = 1; $number <= $quantity_new; $number++) {
      $ticket = $controller->create(array(
        'type' => $config['type'],
        'barcode_token' => commerce_event_ticket_generate_barcode_token(),
        'product_id' => $product->product_id,
        'order_id' => $order->order_id,
        'uid' => $order->uid,
        'line_item_id' => $line_item->line_item_id,
        'number' => $number,
      ));
      $controller->save($ticket, $transaction);
    }

    // Log a message about the newly generated tickets.
    watchdog('commerce_event_ticket', 'Created @new new ticket(s), of @total total, for order number @order and line item ID @line_item.', array(
      '@new' => $quantity_new,
      '@total' => $line_item->quantity,
      '@order' => $order->order_number,
      '@line_item' => $line_item->line_item_id,
    ));
  }
}

/**
 * URI callback for Commerce Event Ticket.
 */
function commerce_event_ticket_uri($entity) {
  return 'user/' . $entity->uid . '/orders/' . $entity->order_id . '/tickets/' . $entity->ticket_id;
}

/**
 * Get the event ticket configuration for a product.
 *
 * @todo
 *
 * @param stdClass $product
 *   The Commerce product object.
 *
 * @return array
 *   Event ticket configuration.
 */
function commerce_event_ticket_get_ticket_config($product) {
  return array(
    'type' => 'ticket',
  );
}
