<?php
/**
 * @file
 * Main file for the Commerce Event Ticket module.
 */

/**
 * Implements hook_entity_info().
 */
function commerce_event_ticket_entity_info() {
  $entities = array();

  $entities['commerce_event_ticket'] = array(
    'label' => t('Ticket'),
    'entity class' => 'CommerceEventTicketEntity',
    'controller class' => 'CommerceEventTicketController',
    'uri callback' => 'commerce_event_ticket_uri',
    'access callback' => 'commerce_event_ticket_access',
    'label callback' => 'commerce_event_ticket_label',
    'base table' => 'commerce_event_ticket',
    'token type' => 'commerce-event-ticket',
    'entity keys' => array(
      'id' => 'ticket_id',
      'bundle' => 'type',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'view modes' => array(
      'customer' => array(
        'label' => t('Customer'),
      ),
      'admin' => array(
        'label' => t('Administrator'),
      ),
      'pdf' => array(
        'label' => t('PDF'),
      ),
    ),
    'view callback' => 'entity_metadata_view_single',
    'static cache' => TRUE,
    'fieldable' => FALSE,
    'module' => 'commerce_event_ticket',
  );

  foreach (commerce_event_ticket_types() as $key => $type) {
    $entities['commerce_event_ticket']['bundles'][$key] = array(
      'label' => $type['name'],
      'admin' => array(
        'path' => 'admin/commerce/config/event-ticket/' . $key,
        'real path' => 'admin/commerce/config/event-ticket/' . $key,
        'bundle argument' => 4,
        'access arguments' => array('administer commerce event ticket'),
      ),
    );
  }

  return $entities;
}

/**
 * Implements hook_permission().
 */
function commerce_event_ticket_permission() {
  return array(
    'administer commerce event ticket' => array(
      'title' => t('Administer event tickets'),
    ),
    'view all commerce event tickets' => array(
      'title' => t('View all event tickets'),
    ),
    'view own commerce event tickets' => array(
      'title' => t('View own event tickets'),
    ),
  );
}

/**
 * Get information about Commerce Event Ticket types.
 *
 * @return array
 *   An array of ticket types, keyed with a unique machine name. Each element is
 *   a structured array, defining at least 'name' (a sanitized human-readable
 *   name).
 */
function commerce_event_ticket_types() {
  $types = &drupal_static(__FUNCTION__);
  if ($types === NULL) {
    $types = array(
      'ticket' => array(
        'name' => t('Event ticket'),
      ),
    );
    $types += module_invoke_all('commerce_event_ticket_info');
    drupal_alter('commerce_event_ticket_info', $types);
  }
  return $types;
}

/**
 * Implements hook_menu().
 */
function commerce_event_ticket_menu() {
  // The configuration form.
  $items['admin/commerce/config/event-ticket'] = array(
    'title' => 'Commerce Event Ticket settings',
    'description' => 'Configure settings for event tickets.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_event_ticket_config'),
    'file' => 'commerce_event_ticket.admin.inc',
    'access arguments' => array('administer commerce event ticket'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/commerce/orders/%commerce_order/tickets/%commerce_event_ticket'] = array(
    'title callback' => 'commerce_event_ticket_label',
    'title arguments' => array(5),
    'page callback' => 'commerce_event_ticket_view',
    'page arguments' => array(5, 'admin'),
    'access callback' => 'commerce_event_ticket_access',
    'access arguments' => array('view', 5),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );
  $items['admin/commerce/orders/%commerce_order/tickets'] = array(
    'title' => 'Tickets',
    'page callback' => 'commerce_event_ticket_list',
    'page arguments' => array(3, 'admin'),
    'file' => 'commerce_event_ticket.pages.inc',
    'access callback' => 'commerce_event_ticket_access_by_order',
    'access arguments' => array(3),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );
  $items['user/%user/orders/%commerce_order/tickets'] = array(
    'title' => 'Tickets',
    'page callback' => 'commerce_event_ticket_list',
    'page arguments' => array(3, 'customer'),
    'file' => 'commerce_event_ticket.pages.inc',
    'access callback' => 'commerce_event_ticket_access_by_order',
    'access arguments' => array(3),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );
  $items['user/%user/orders/%commerce_order/tickets/%commerce_event_ticket'] = array(
    'title callback' => 'commerce_event_ticket_label',
    'title arguments' => array(5),
    'page callback' => 'commerce_event_ticket_page',
    'page arguments' => array(5, 'customer'),
    'file' => 'commerce_event_ticket.pages.inc',
    'access callback' => 'commerce_event_ticket_access',
    'access arguments' => array('view', 5),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );
  return $items;
}

/**
 * View callback for an event ticket.
 */
function commerce_event_ticket_view($ticket, $view_mode = 'customer') {
  return array(
    '#theme' => 'commerce_event_ticket',
    '#view_mode' => $view_mode,
    '#ticket' => $ticket,
  );
}

/**
 * Implements hook_theme().
 */
function commerce_event_ticket_theme() {
  return array(
    'commerce_event_ticket' => array(
      'variables' => array(
        'view_mode' => 'customer',
        'ticket' => NULL,
      ),
      'file' => 'commerce_event_ticket.theme.inc',
    ),
  );
}

/**
 * Access callback for a list of tickets attached to an order.
 */
function commerce_event_ticket_access_by_order($order, $account = NULL) {
  if (!$account) {
    $account = $GLOBALS['user'];
  }
  if (!user_access('view all commerce event tickets', $account)
    && ($account->uid != $order->uid
      || !user_access('view own commerce event tickets', $account))) {
    return FALSE;
  }
  if (!_commerce_event_ticket_order_should_have_tickets($order)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Access callback for an event ticket.
 */
function commerce_event_ticket_access($op, $entity, $account = NULL) {
  // Operations other than 'view' make no sense.
  if ($op != 'view') {
    return FALSE;
  }
  if (!$account) {
    $account = $GLOBALS['user'];
  }
  if (!empty($account->uid)
    && $account->uid == $entity->uid
    && user_access('view own commerce event tickets', $account)) {
    return TRUE;
  }
  if (user_access('view all commerce event tickets', $account)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Load an event ticket.
 */
function commerce_event_ticket_load($ticket_id) {
  $tickets = commerce_event_ticket_load_multiple(array($ticket_id));
  return $tickets ? reset($tickets) : FALSE;
}

/**
 * Load multiple event ticket(s).
 */
function commerce_event_ticket_load_multiple($ticket_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('commerce_event_ticket', $ticket_ids, $conditions, $reset);
}

/**
 * Get all the ticket IDs for an order.
 */
function commerce_event_ticket_find_by_order($order) {
  $tickets = &drupal_static(__FUNCTION__, array());
  if (!isset($tickets[$order->order_id])) {
    $tickets[$order->order_id] = array();
    // Check whether the token already exists.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'commerce_event_ticket')
      ->propertyCondition('order_id', $order->order_id);
    $result = $query->execute();
    if (isset($result['commerce_event_ticket'])) {
      $tickets[$order->order_id] = array_keys($result['commerce_event_ticket']);
    }
  }
  return $tickets[$order->order_id];
}

/**
 * Save an event ticket.
 */
function commerce_event_ticket_save($ticket) {
  return entity_get_controller('commerce_event_ticket')->save($ticket);
}

/**
 * Delete an event ticket.
 */
function commerce_event_ticket_delete($ticket_id) {
  return commerce_event_ticket_delete_multiple(array($ticket_id));
}


/**
 * Delete multiple event ticket(s).
 */
function commerce_event_ticket_delete_multiple(array $ticket_ids) {
  return entity_get_controller('commerce_event_ticket')->delete($ticket_ids);
}

/**
 * Delete all the tickets associated with the specified line item.
 */
function commerce_event_ticket_delete_by_line_item($line_item) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_event_ticket')
    ->propertyCondition('line_item_id', $line_item->line_item_id);
  $result = $query->execute();
  if (!empty($result['commerce_event_ticket'])) {
    $ids = array_keys($result['commerce_event_ticket']);
    commerce_event_ticket_delete_multiple($ids);
  }
}

/**
 * Implements hook_entity_delete().
 */
function commerce_event_ticket_entity_delete($entity, $type) {
  if ($type == 'commerce_line_item') {
    commerce_event_ticket_delete_by_line_item($entity);
  }
}

/**
 * Label callback for Commerce Event Ticket.
 */
function commerce_event_ticket_label($entity) {
  $product = commerce_product_load($entity->product_id);
  return t('Ticket @ticket (@product)', array(
    '@ticket' => $entity->ticket_id,
    '@product' => $product->title,
  ));
}

/**
 * Count the number of event tickets that already exist for a line item.
 *
 * @param int $line_item
 *   The Commerce line item object.
 *
 * @return int
 *   The number of event tickets that have already been created for this line
 *   item.
 */
function commerce_event_ticket_count($line_item) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_event_ticket')
    ->propertyCondition('line_item_id', $line_item->line_item_id);
  $result = $query->execute();
  if (isset($result['commerce_event_ticket'])) {
    return count($result['commerce_event_ticket']);
  }
  return 0;
}

/**
 * Generate a new barcode token for the ticket.
 *
 * @param string $prefix
 *   A prefix to prepend to the token.
 * @param int $length
 *   The length of the remainder of the token.
 * @param int $recursed
 *   A count of how many times this function has recursed.
 *
 * @return string
 *   A random barcode token.
 */
function commerce_event_ticket_generate_barcode_token($prefix = '', $length = 10, $recursed = 0) {
  // Fail if the function has recursed more than 100 times.
  if ($recursed > 100) {
    throw new Exception(
      t('Failed to generate a new barcode token (prefix @prefix, length @length).', array(
        '@prefix' => $prefix,
        '@length' => $length,
      ))
    );
  }
  // Make a new random token.
  $integers = range(0, 9);
  shuffle($integers);
  $token = $prefix;
  for ($i = 0; $i < $length; $i++) {
    $token .= $integers[$i];
  }
  // Check whether the token already exists.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_event_ticket')
    ->propertyCondition('barcode_token', $token)
    ->count();
  $count = $query->execute();
  // If it does already exist, then recurse to find a new token.
  if ($count) {
    return commerce_event_ticket_generate_barcode_token($prefix, $length, $recursed + 1);
  }
  $tokens_cache[] = $token;
  return $token;
}

/**
 * Check whether an order should have tickets generated for it.
 */
function _commerce_event_ticket_order_should_have_tickets($order, $reset = FALSE) {
  $cache = &drupal_static(__FUNCTION__, array());
  if (!isset($cache[$order->order_id]) || $reset) {
    $cache[$order->order_id] = FALSE;
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
    // Find line items in the order.
    foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
      $line_item = $line_item_wrapper->value();

      // Check that the line item is a product.
      if ($line_item->type != 'product') {
        continue;
      }

      // Check that the product is configured to have tickets.
      $product = $line_item_wrapper->commerce_product->value();
      if (commerce_event_ticket_product_is_ticket($product)) {
        $cache[$order->order_id] = TRUE;
        break;
      }
    }
  }
  return $cache[$order->order_id];
}

/**
 * Create event tickets for an order.
 *
 * This is provided as a Rules action.
 *
 * @param stdClass $order
 *   The Commerce order object.
 */
function commerce_event_ticket_create_from_order($order) {
  if (!_commerce_event_ticket_order_should_have_tickets($order)) {
    return;
  }
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  // Find line items in the order.
  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    $line_item = $line_item_wrapper->value();

    // Check that the line item is a product.
    if ($line_item->type != 'product') {
      continue;
    }

    // Check that the product is configured to have tickets.
    $product = $line_item_wrapper->commerce_product->value();
    if (!commerce_event_ticket_product_is_ticket($product)) {
      continue;
    }

    // Check what quantity of tickets should be generated.
    $existing = commerce_event_ticket_count($line_item);
    $created = 0;
    $to_create = $line_item->quantity - $existing;

    // Generate the new tickets.
    $controller = entity_get_controller('commerce_event_ticket');
    $transaction = db_transaction();
    for ($number = 1; $number <= $to_create; $number++) {
      $ticket = $controller->create(array(
        // The commerce_event_ticket bundle is always 'ticket' for now.
        'type' => 'ticket',
        // Generate a secure barcode token for this individual ticket.
        'barcode_token' => commerce_event_ticket_generate_barcode_token(),
        'product_id' => $product->product_id,
        'order_id' => $order->order_id,
        'uid' => $order->uid,
        'line_item_id' => $line_item->line_item_id,
        'number' => $number,
      ));
      $success = $controller->save($ticket, $transaction);
      if ($success) {
        $created++;
      }
    }

    // Log a message about the newly generated tickets.
    watchdog('commerce_event_ticket', 'Created @new/@to_create new ticket(s) of @total total, for order number @order and line item ID @line_item.', array(
      '@new' => $created,
      '@to_create' => $to_create,
      '@total' => intval($line_item->quantity),
      '@order' => $order->order_number,
      '@line_item' => $line_item->line_item_id,
    ));
  }
}

/**
 * URI callback for Commerce Event Ticket.
 */
function commerce_event_ticket_uri($entity) {
  return 'user/' . $entity->uid . '/orders/' . $entity->order_id . '/tickets/' . $entity->ticket_id;
}

/**
 * Find out whether a product is a ticket.
 *
 * @param stdClass $product
 *   The Commerce product object.
 *
 * @return bool
 *   TRUE if the product is of a type that's defined as a ticket.
 */
function commerce_event_ticket_product_is_ticket($product) {
  $types = variable_get('commerce_event_ticket_product_types', array('ticket'));
  if (!empty($types[$product->type])) {
    return TRUE;
  }
  return FALSE;
}
