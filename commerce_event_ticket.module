<?php
/**
 * @file
 * Main file for the Commerce Event Ticket module.
 */

/**
 * Implements hook_entity_info().
 */
function commerce_event_ticket_entity_info() {
  $entities = array();

  $entities['commerce_event_ticket'] = array(
    'label' => t('Ticket'),
    'entity class' => 'CommerceEventTicketEntity',
    'controller class' => 'CommerceEventTicketController',
    'uri callback' => 'commerce_event_ticket_uri',
    'access callback' => 'commerce_event_ticket_access',
    'label callback' => 'commerce_event_ticket_label',
    'base table' => 'commerce_event_ticket',
    'token type' => 'commerce-event-ticket',
    'entity keys' => array(
      'id' => 'ticket_id',
      'bundle' => 'type',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'view modes' => array(
      'customer' => array(
        'label' => t('Customer'),
      ),
      'admin' => array(
        'label' => t('Administrator'),
      ),
    ),
    'view callback' => 'entity_metadata_view_single',
    'static cache' => TRUE,
    'fieldable' => TRUE,
    'module' => 'commerce_event_ticket',
  );

  foreach (commerce_event_ticket_types() as $key => $type) {
    $entities['commerce_event_ticket']['bundles'][$key] = array(
      'label' => $type['name'],
      'admin' => array(
        'path' => 'admin/commerce/config/event-ticket/' . $key,
        'real path' => 'admin/commerce/config/event-ticket/' . $key,
        'bundle argument' => 4,
        'access arguments' => array('administer commerce event ticket'),
      ),
    );
  }

  return $entities;
}

/**
 * Implements hook_permission().
 */
function commerce_event_ticket_permission() {
  return array(
    'administer commerce event ticket' => array(
      'title' => t('Administer event tickets'),
    ),
    'view all commerce event tickets' => array(
      'title' => t('View all event tickets'),
    ),
    'view own commerce event tickets' => array(
      'title' => t('View own event tickets'),
    ),
  );
}

/**
 * Get information about Commerce Event Ticket types.
 *
 * @return array
 *   An array of ticket types, keyed with a unique machine name. Each element is
 *   a structured array, defining at least 'name' (a sanitized human-readable
 *   name).
 */
function commerce_event_ticket_types() {
  $types = &drupal_static(__FUNCTION__);
  if ($types === NULL) {
    $types = array(
      'ticket' => array(
        'name' => t('Event ticket'),
      ),
    );
    $types += module_invoke_all('commerce_event_ticket_info');
    drupal_alter('commerce_event_ticket_info', $types);
  }
  return $types;
}

/**
 * Implements hook_menu().
 */
function commerce_event_ticket_menu() {
  // The configuration form.
  $items['admin/commerce/config/event-ticket'] = array(
    'title' => 'Commerce Event Ticket settings',
    'description' => 'Configure settings for event tickets.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_event_ticket_config'),
    'file' => 'includes/commerce_event_ticket.admin.inc',
    'access arguments' => array('administer commerce event ticket'),
  );
  $items['admin/commerce/config/event-ticket/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/commerce/orders/%commerce_order/tickets/%commerce_event_ticket'] = array(
    'title callback' => 'commerce_event_ticket_label',
    'title arguments' => array(5),
    'page callback' => 'commerce_event_ticket_view',
    'page arguments' => array(5, 'admin'),
    'access callback' => 'commerce_event_ticket_access',
    'access arguments' => array('view', 5),
  );
  $items['user/%user/orders/%commerce_order/tickets/%commerce_event_ticket'] = array(
    'title callback' => 'commerce_event_ticket_label',
    'title arguments' => array(5),
    'page callback' => 'commerce_event_ticket_page',
    'page arguments' => array(5, 'customer'),
    'file' => 'includes/commerce_event_ticket.pages.inc',
    'access callback' => 'commerce_event_ticket_access',
    'access arguments' => array('view', 5),
  );
  return $items;
}

/**
 * View callback for an event ticket.
 */
function commerce_event_ticket_view($ticket, $view_mode = 'customer') {
  return array(
    '#theme' => 'commerce_event_ticket',
    '#view_mode' => $view_mode,
    '#ticket' => $ticket,
  );
}

/**
 * Implements hook_theme().
 */
function commerce_event_ticket_theme() {
  return array(
    'commerce_event_ticket' => array(
      'variables' => array(
        'view_mode' => 'customer',
        'ticket' => NULL,
      ),
      'file' => 'includes/commerce_event_ticket.theme.inc',
    ),
  );
}

/**
 * Access callback for a list of tickets attached to an order.
 */
function commerce_event_ticket_access_by_order($order, $account = NULL) {
  if (!$account) {
    $account = $GLOBALS['user'];
  }
  if (!user_access('view all commerce event tickets', $account)
    && ($account->uid != $order->uid
      || !user_access('view own commerce event tickets', $account))) {
    return FALSE;
  }
  if (!_commerce_event_ticket_order_should_have_tickets($order)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Implements hook_file_download_access().
 */
function commerce_event_ticket_file_download_access($file_item, $entity_type, $entity) {
  if ($entity_type == 'commerce_event_ticket') {
    return commerce_event_ticket_access('view', $entity);
  }
}

/**
 * Validate a ticket.
 *
 * @param CommerceEventTicket $ticket
 *   The ticket entity.
 *
 * @return bool
 *   TRUE if the ticket is valid and may be used to enter the event, FALSE
 *   otherwise.
 *
 * @todo make an API function to check based on barcode token only
 */
function commerce_event_ticket_is_valid(CommerceEventTicket $ticket) {
  // Check that the ticket's line item still exists attached to the same order.
  $query = new EntityFieldQuery();
  $exists = $query->entityCondition('entity_type', 'commerce_line_item')
      ->propertyCondition('order_id', $ticket->order_id)
      ->propertyCondition('type', 'product')
      ->count()
      ->execute();
  if (!$exists) {
    return FALSE;
  }
  // Check the order status.
  $order = commerce_order_load($ticket->order_id);
  // @todo make this configurable and delete the var on uninstall
  if (!in_array($order->status, variable_get('commerce_event_ticket_valid_statuses', array('complete')))) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Access callback for an event ticket.
 */
function commerce_event_ticket_access($op, $entity, $account = NULL) {
  // Operations other than 'view' make no sense.
  if ($op != 'view') {
    return FALSE;
  }
  if (!$account) {
    $account = $GLOBALS['user'];
  }
  if (!empty($account->uid)
    && $account->uid == $entity->uid
    && user_access('view own commerce event tickets', $account)) {
    return TRUE;
  }
  if (user_access('view all commerce event tickets', $account)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Check whether an event ticket is valid.
 */
function commerce_event_ticket_validate($ticket) {

}

/**
 * Load an event ticket.
 */
function commerce_event_ticket_load($ticket_id) {
  $tickets = commerce_event_ticket_load_multiple(array($ticket_id));
  return $tickets ? reset($tickets) : FALSE;
}

/**
 * Load multiple event ticket(s).
 */
function commerce_event_ticket_load_multiple($ticket_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('commerce_event_ticket', $ticket_ids, $conditions, $reset);
}

/**
 * Load an event ticket by a given barcode token.
 *
 * @return CommerceEventTicket|FALSE
 */
function commerce_event_ticket_load_by_token($barcode_token) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_event_ticket')
    ->propertyCondition('barcode_token', $barcode_token);
  $result = $query->execute();
  if (!empty($result['commerce_event_ticket'])) {

  }
  return FALSE;
}

/**
 * Get all the ticket IDs for an order.
 */
function commerce_event_ticket_find_by_order($order) {
  $tickets = &drupal_static(__FUNCTION__, array());
  if (!isset($tickets[$order->order_id])) {
    $tickets[$order->order_id] = array();
    // Search for all tickets with this order ID.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'commerce_event_ticket')
      ->propertyCondition('order_id', $order->order_id);
    $result = $query->execute();
    if (isset($result['commerce_event_ticket'])) {
      $tickets[$order->order_id] = array_keys($result['commerce_event_ticket']);
    }
  }
  return $tickets[$order->order_id];
}

/**
 * Save an event ticket.
 */
function commerce_event_ticket_save($ticket) {
  return entity_get_controller('commerce_event_ticket')->save($ticket);
}

/**
 * Delete an event ticket.
 */
function commerce_event_ticket_delete($ticket_id) {
  return commerce_event_ticket_delete_multiple(array($ticket_id));
}


/**
 * Delete multiple event ticket(s).
 */
function commerce_event_ticket_delete_multiple(array $ticket_ids) {
  return entity_get_controller('commerce_event_ticket')->delete($ticket_ids);
}

/**
 * Delete all the tickets associated with the specified line item.
 */
function commerce_event_ticket_delete_by_line_item($line_item) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_event_ticket')
    ->propertyCondition('line_item_id', $line_item->line_item_id);
  $result = $query->execute();
  if (!empty($result['commerce_event_ticket'])) {
    $ids = array_keys($result['commerce_event_ticket']);
    commerce_event_ticket_delete_multiple($ids);
  }
}

/**
 * Implements hook_entity_delete().
 */
function commerce_event_ticket_entity_delete($entity, $type) {
  if ($type == 'commerce_line_item') {
    commerce_event_ticket_delete_by_line_item($entity);
  }
}

/**
 * Label callback for Commerce Event Ticket.
 */
function commerce_event_ticket_label($entity) {
  $product = commerce_product_load($entity->product_id);
  return t('Ticket @ticket (@product)', array(
    '@ticket' => $entity->ticket_id,
    '@product' => $product->title,
  ));
}

/**
 * Count the number of event tickets that already exist for a line item.
 *
 * @param int $line_item
 *   The Commerce line item object.
 *
 * @return int
 *   The number of event tickets that have already been created for this line
 *   item.
 */
function commerce_event_ticket_count($line_item) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_event_ticket')
    ->propertyCondition('line_item_id', $line_item->line_item_id);
  $result = $query->execute();
  if (isset($result['commerce_event_ticket'])) {
    return count($result['commerce_event_ticket']);
  }
  return 0;
}

/**
 * Generate a new random barcode token for the ticket.
 *
 * The core function drupal_get_token() is not used here, because barcode tokens
 * may need to be quite short.
 *
 * @param int $length
 *   The desired length of the token (default 15).
 * @param bool $alpha
 *   Whether to include alphabetical characters in the token (default TRUE).
 * @param bool $unique
 *   Whether to check that the token is unique (default TRUE). In some cases you
 *   may not need a unique token, e.g. if you're going to prefix it by something
 *   else.
 *
 * @return string
 *   A random barcode token.
 */
function commerce_event_ticket_generate_barcode_token($length = 10, $alpha = TRUE, $unique = TRUE) {
  static $chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  // Make a new random alphanumeric token. This method below means that rand()
  // will be called $length times. It seems to be more random than using
  // shuffle($chars), because it allows for characters to be repeated within the
  // token.
  $limit = $alpha ? 35 : 9;
  for ($token = '', $i = 0; $i < $length; $i++) {
    $token .= $chars[rand(0, $limit)];
  }
  // Uniqueness check. Find out whether the token already exists. If it does,
  // recurse to find a new token.
  if ($unique) {
    $query = new EntityFieldQuery();
    $count = $query->entityCondition('entity_type', 'commerce_event_ticket')
      ->propertyCondition('barcode_token', $token)
      ->count()
      ->execute();
    if ($count) {
      return commerce_event_ticket_generate_barcode_token($length, $alpha);
    }
  }
  return $token;
}

/**
 * Check whether an order should have tickets generated for it.
 */
function _commerce_event_ticket_order_should_have_tickets($order, $reset = FALSE) {
  $cache = &drupal_static(__FUNCTION__, array());
  if (!isset($cache[$order->order_id]) || $reset) {
    $cache[$order->order_id] = FALSE;
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
    // Find line items in the order.
    foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
      $line_item = $line_item_wrapper->value();

      // Check that the line item is a product.
      if ($line_item->type != 'product') {
        continue;
      }

      // Check that the product is configured to have tickets.
      $product = $line_item_wrapper->commerce_product->value();
      if (commerce_event_ticket_product_is_ticket($product)) {
        $cache[$order->order_id] = TRUE;
        break;
      }
    }
  }
  return $cache[$order->order_id];
}

/**
 * Create event tickets for a line item.
 */
function commerce_event_ticket_create_from_line_item($line_item) {
  // Check that the line item is a product.
  if ($line_item->type != 'product') {
    continue;
  }

  // Check that the product is configured to have tickets.
  $product = $line_item_wrapper->commerce_product->value();
  if (!commerce_event_ticket_product_is_ticket($product)) {
    continue;
  }

  // Find out the number of tickets to create.
  $to_create = $line_item->quantity;
  if ($to_create == 0) {
    continue;
  }

  $transaction = db_transaction();

  // If recreating, delete existing tickets for this line item first.
  if ($recreate) {
    commerce_event_ticket_delete_by_line_item($line_item);
  }
  // Otherwise, check the number of existing tickets for this line item.
  else {
    $existing = commerce_event_ticket_count($line_item);
    $to_create -= $existing;
    if ($existing > 0) {
      // @todo make sure the starting $number is correct
    }
    if ($to_create == 0) {
      continue;
    }
  }

  // Create the new tickets.
  $controller = entity_get_controller('commerce_event_ticket');
  $created = 0;
  for ($number = 1; $number <= $to_create; $number++) {
    $ticket = $controller->create(array(
      // The commerce_event_ticket bundle is always 'ticket' for now.
      'type' => 'ticket',
      // Generate a secure barcode token for this individual ticket.
      'barcode_token' => commerce_event_ticket_generate_barcode_token(),
      'product_id' => $product->product_id,
      'order_id' => $line_item->order_id,
      'line_item_id' => $line_item->line_item_id,
      'number' => $number,
    ));
    $controller->save($ticket, $transaction);
  }
}

/**
 * Create event tickets for an order.
 *
 * This is provided as a Rules action.
 *
 * @param stdClass $order
 *   The Commerce order object.
 * @param bool $recreate
 *   Whether to recreate tickets (invalidating any old ones). Defaults to FALSE.
 */
function commerce_event_ticket_create_from_order($order, $recreate = FALSE) {
  if (!_commerce_event_ticket_order_should_have_tickets($order)) {
    return;
  }
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  // Find line items in the order.
  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    commerce_event_ticket_create_from_line_item($line_item_wrapper->value());
  }
}

/**
 * URI callback for Commerce Event Ticket.
 */
function commerce_event_ticket_uri($entity) {
  return array(
    'path' => 'user/' . $entity->uid . '/orders/' . $entity->order_id . '/tickets/' . $entity->ticket_id,
  );
}

/**
 * Find out whether a product is a ticket.
 *
 * @param stdClass $product
 *   The Commerce product object.
 *
 * @return bool
 *   TRUE if the product is of a type that's defined as a ticket.
 */
function commerce_event_ticket_product_is_ticket($product) {
  $types = variable_get('commerce_event_ticket_product_types', array('ticket'));
  if (!empty($types[$product->type])) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_views_api().
 */
function commerce_event_ticket_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_event_ticket') . '/includes',
  );
}
